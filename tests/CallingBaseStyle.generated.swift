/// Autogenerated file

// swiftlint:disable all
import UIKit

fileprivate extension UserDefaults {
	subscript<T>(key: String) -> T? {
		get { return value(forKey: key) as? T }
		set { set(newValue, forKey: key) }
	}

	subscript<T: RawRepresentable>(key: String) -> T? {
		get {
			if let rawValue = value(forKey: key) as? T.RawValue {
				return T(rawValue: rawValue)
			}
			return nil
		}
		set { self[key] = newValue?.rawValue }
	}
}

public enum Theme: Int {
	case callingBase
	case callingTeams

	public var stylesheet: CallingBaseStyle {
		switch self {
		case .callingBase: return CallingBaseStyle.shared()
		case .callingTeams: return CallingTeamsStyle.shared()
		}
	}
}

public extension Notification.Name {
	static let didChangeTheme = Notification.Name("stylesheet.theme")
}

public class StylesheetManager {
	@objc dynamic public class func stylesheet(_ stylesheet: CallingBaseStyle) -> CallingBaseStyle {
		return StylesheetManager.default.theme.stylesheet
	}

	private struct DefaultKeys {
		static let theme = "theme"
	}

	public static let `default` = StylesheetManager()
	public static var S: CallingBaseStyle {
		return StylesheetManager.default.theme.stylesheet
	}

	public var theme: Theme {
		didSet {
			NotificationCenter.default.post(name: .didChangeTheme, object: theme)
			UserDefaults.standard[DefaultKeys.theme] = theme
		}
	}

	public init() {
		self.theme = UserDefaults.standard[DefaultKeys.theme] ?? .callingBase
	}
}

public class Application {
	@objc dynamic public class func preferredContentSizeCategory() -> UIContentSizeCategory {
		return .large
	}
}

fileprivate var __ApperanceProxyHandle: UInt8 = 0
fileprivate var __ThemeAwareHandle: UInt8 = 0
fileprivate var __ObservingDidChangeThemeHandle: UInt8 = 0

/// Your view should conform to 'AppearaceProxyComponent'.
public protocol AppearaceProxyComponent: class {
	associatedtype ApperanceProxyType
	var appearanceProxy: ApperanceProxyType { get }
	var themeAware: Bool { get set }
	func didChangeAppearanceProxy()
}

public extension AppearaceProxyComponent {
	func initAppearanceProxy(themeAware: Bool = true) {
		self.themeAware = themeAware
		didChangeAppearanceProxy()
	}
}

#if os(iOS)
private let defaultSizes: [UIFont.TextStyle: CGFloat] = {
	var sizes: [UIFont.TextStyle: CGFloat] = [.caption2: 11,
	.caption1: 12,
	.footnote: 13,
	.subheadline: 15,
	.callout: 16,
	.body: 17,
	.headline: 17,
	.title3: 20,
	.title2: 22,
	.title1: 28]
	if #available(iOS 11.0, *) {
		sizes[.largeTitle] = 34
	}
	return sizes
}()
#elseif os(tvOS)
private let defaultSizes: [UIFont.TextStyle: CGFloat] =
	[.caption2: 23,
		.caption1: 25,
		.footnote: 29,
		.subheadline: 29,
		.body: 29,
		.callout: 31,
		.headline: 38,
		.title3: 48,
		.title2: 57,
		.title1: 76]
#elseif os(watchOS)
private let defaultSizes: [UIFont.TextStyle: CGFloat] = {
	if #available(watchOS 5.0, *) {
		switch WKInterfaceDevice.current().preferredContentSizeCategory {
		case "UICTContentSizeCategoryS":
			return [.footnote: 12,
				.caption2: 13,
				.caption1: 14,
				.body: 15,
				.headline: 15,
				.title3: 18,
				.title2: 26,
				.title1: 30,
				.largeTitle: 32]
		case "UICTContentSizeCategoryL":
			return [.footnote: 13,
				.caption2: 14,
				.caption1: 15,
				.body: 16,
				.headline: 16,
				.title3: 19,
				.title2: 27,
				.title1: 34,
				.largeTitle: 36]
		case "UICTContentSizeCategoryXL":
			return [.footnote: 14,
				.caption2: 15,
				.caption1: 16,
				.body: 17,
				.headline: 17,
				.title3: 20,
				.title2: 30,
				.title1: 38,
				.largeTitle: 40]
		default:
			return [:]
		}
	} else {
		/// No `largeTitle` before watchOS 5
		switch WKInterfaceDevice.current().preferredContentSizeCategory {
		case "UICTContentSizeCategoryS":
			return [.footnote: 12,
					.caption2: 13,
					.caption1: 14,
					.body: 15,
					.headline: 15,
					.title3: 18,
					.title2: 26,
					.title1: 30]
		case "UICTContentSizeCategoryL":
			return [.footnote: 13,
					.caption2: 14,
					.caption1: 15,
					.body: 16,
					.headline: 16,
					.title3: 19,
					.title2: 27,
					.title1: 34]
		default:
			return [:]
		}
	}
}()
#endif

fileprivate var __ScalableHandle: UInt8 = 0
public extension UIFont {
	static func scaledFont(name: String, textStyle: UIFont.TextStyle, traitCollection: UITraitCollection? = nil) -> UIFont {
		if #available(iOS 11.0, *) {
			guard let defaultSize = defaultSizes[textStyle], let customFont = UIFont(name: name, size: defaultSize) else {
				fatalError("Failed to load the \(name) font.")
			}
			return UIFontMetrics(forTextStyle: textStyle).scaledFont(for: customFont, compatibleWith: traitCollection)
		} else {
			let fontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: textStyle, compatibleWith: traitCollection)
			guard let customFont = UIFont(name: name, size: fontDescriptor.pointSize) else {
				fatalError("Failed to load the \(name) font.")
			}
			return customFont
		}
	}

	func with(traits: UIFontDescriptor.SymbolicTraits) -> UIFont {
		let descriptor = fontDescriptor.withSymbolicTraits(traits)
		return UIFont(descriptor: descriptor!, size: 0)
	}

	class func preferredFont(forTextStyle style: UIFont.TextStyle, compatibleWith traitCollection: UITraitCollection?, scalable: Bool) -> UIFont {
		let font = UIFont.preferredFont(forTextStyle: style, compatibleWith: traitCollection)
		font.isScalable = true
		return font
	}

	convenience init?(name: String, scalable: Bool) {
		self.init(name: name, size: 4)
		self.isScalable = scalable
	}

	var isScalable: Bool {
		get { return objc_getAssociatedObject(self, &__ScalableHandle) as? Bool ?? false }
		set { objc_setAssociatedObject(self, &__ScalableHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}

}

fileprivate var __AnimatorProxyHandle: UInt8 = 0
fileprivate var __AnimatorRepeatCountHandle: UInt8 = 0
fileprivate var __AnimatorIdentifierHandle: UInt8 = 0

/// Your view should conform to 'AnimatorProxyComponent'.
public protocol AnimatorProxyComponent: class {
	associatedtype AnimatorProxyType
	var animator: AnimatorProxyType { get }

}


public struct KeyFrame {
	var relativeStartTime: CGFloat
	var relativeDuration: CGFloat?
	var values: [AnimatableProp]
}

public enum AnimationAction {
	case start
	case pause
	case stop(withoutFinishing: Bool)
	case fractionComplete(CGFloat)
}

public struct AnimationConfigOptions {
	let repeatCount: AnimationRepeatCount?
	let delay: CGFloat?
	let duration: TimeInterval?
	let curve: AnimationCurveType?
	let scrubsLinearly: Bool?

	public init(duration: TimeInterval? = nil, delay: CGFloat? = nil, repeatCount: AnimationRepeatCount? = nil, curve: AnimationCurveType? = nil, scrubsLinearly: Bool? = nil) {
		self.duration = duration
		self.delay = delay
		self.repeatCount = repeatCount
		self.curve = curve
		self.scrubsLinearly = scrubsLinearly
	}
}

public enum AnimationRepeatCount {
	case infinite
	case count(Int)
}

public enum AnimationCurveType {
	case native(UIView.AnimationCurve)
	case timingParameters(UITimingCurveProvider)
}

public enum AnimationType {
	case rotate
}

public enum AnimatableProp: Equatable {
	case opacity(from: CGFloat?, to: CGFloat)
	case frame(from: CGRect?, to: CGRect)
	case size(from: CGSize?, to: CGSize)
	case width(from: CGFloat?, to: CGFloat)
	case height(from: CGFloat?, to: CGFloat)
	case left(from: CGFloat?, to: CGFloat)
	case rotate(from: CGFloat?, to: CGFloat)
}


public extension AnimatableProp {
	func applyFrom(to view: UIView) {
		switch self {
		case .opacity(let from, _):	if let from = from { view.alpha = from }
		case .frame(let from, _):	if let from = from { view.frame = from }
		case .size(let from, _):	if let from = from { view.bounds.size = from }
		case .width(let from, _):	if let from = from { view.bounds.size.width = from }
		case .height(let from, _):	if let from = from { view.bounds.size.height = from }
		case .left(let from, _):	if let from = from { view.frame.origin.x = from }
		case .rotate(let from, _):	if let from = from { view.transform = view.transform.rotated(by: (from * .pi / 180.0)) }
		}
	}

	func applyTo(to view: UIView) {
		switch self {
		case .opacity(_, let to):	view.alpha = to
		case .frame(_, let to):		view.frame = to
		case .size(_, let to):		view.bounds.size = to
		case .width(_, let to):		view.bounds.size.width = to
		case .height(_, let to):	view.bounds.size.height = to
		case .left(_, let to):		view.frame.origin.x = to
		case .rotate(_, let to):	view.transform = view.transform.rotated(by: (to * .pi / 180.0))
		}
	}

}

public struct S {

public enum TextAlignment {
	case natural
	case left
	case right
	case center
	case justified
}

public enum ViewAlignment {
	case leading
	case trailing
	case center
	case justified
	case top
	case bottom
}

public enum ViewContentMode {
	case scaleToFill
	case scaleAspectFit
	case scaleAspectFill
	case redraw
	case center
	case top
	case bottom
	case left
	case right
	case topLeft
	case topRight
	case bottomLeft
	case bottomRight
}

public enum ViewPosition {
	case right
	case bottomRight
	case bottom
	case bottomLeft
	case left
	case topLeft
	case top
	case topRight
}

public enum ViewSize {
	case micro
	case mini
	case tiny
	case small
	case normal
	case large
	case big
	case huge
	case massive
}

public enum LineBreakMode {
	case byWordWrapping
	case byCharWrapping
	case byClipping
	case byTruncatingHead
	case byTruncatingTail
	case byTruncatingMiddle
}

public enum StatusBarStyle {
	case `default`
	case lightContent
}

public enum KeyboardAppearance {
	case `default`
	case dark
	case light
}

public enum AvatarSize {
	case smallest
	case small
}

public struct BitMask: OptionSet, Hashable {
	public let rawValue: Int
	public init(rawValue: Int) { self.rawValue = rawValue }

	public static let left = BitMask(rawValue: 1 << 0)
	public static let right = BitMask(rawValue: 1 << 1)
	public static let all: BitMask = [
		.left, .right
	]
}

public struct CornerMask: OptionSet, Hashable {
	public let rawValue: Int
	public init(rawValue: Int) { self.rawValue = rawValue }

	public static let bottomRight = CornerMask(rawValue: 1 << 0)
	public static let topRight = CornerMask(rawValue: 1 << 1)
	public static let bottomLeft = CornerMask(rawValue: 1 << 2)
	public static let topLeft = CornerMask(rawValue: 1 << 3)
	public static let allCorners: CornerMask = [
		.bottomRight, .topRight, .bottomLeft, .topLeft
	]
}

public struct UnderlineStyle: OptionSet, Hashable {
	public let rawValue: Int
	public init(rawValue: Int) { self.rawValue = rawValue }

	public static let none = UnderlineStyle(rawValue: 1 << 0)
	public static let single = UnderlineStyle(rawValue: 1 << 1)
	public static let thick = UnderlineStyle(rawValue: 1 << 2)
	public static let double = UnderlineStyle(rawValue: 1 << 3)
	public static let patternSolid = UnderlineStyle(rawValue: 1 << 4)
	public static let patternDot = UnderlineStyle(rawValue: 1 << 5)
	public static let patternDash = UnderlineStyle(rawValue: 1 << 6)
	public static let patterDashDot = UnderlineStyle(rawValue: 1 << 7)
	public static let patternDashDotDot = UnderlineStyle(rawValue: 1 << 8)
	public static let byWord = UnderlineStyle(rawValue: 1 << 9)
}

}
/// Entry point for the app stylesheet
public class CallingBaseStyle: NSObject {

	public class func shared() -> CallingBaseStyle {
		 struct __ { static let _sharedInstance = CallingBaseStyle() }
		return __._sharedInstance
	}
	//MARK: - Enums
	public var _Enums: EnumsAppearanceProxy?
	open func EnumsStyle() -> EnumsAppearanceProxy {
		if let override = _Enums { return override }
			return EnumsAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
		}
	public var Enums: EnumsAppearanceProxy {
		get { return self.EnumsStyle() }
		set { _Enums = newValue }
	}
	open class EnumsAppearanceProxy {
		public let mainProxy: () -> CallingBaseStyle
		public init(proxy: @escaping () -> CallingBaseStyle) {
			self.mainProxy = proxy
		}
	}
	//MARK: - Duration
	public var _Duration: DurationAppearanceProxy?
	open func DurationStyle() -> DurationAppearanceProxy {
		if let override = _Duration { return override }
			return DurationAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
		}
	public var Duration: DurationAppearanceProxy {
		get { return self.DurationStyle() }
		set { _Duration = newValue }
	}
	open class DurationAppearanceProxy {
		public let mainProxy: () -> CallingBaseStyle
		public init(proxy: @escaping () -> CallingBaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: - interval
		public var _interval: intervalAppearanceProxy?
		open func intervalStyle() -> intervalAppearanceProxy {
			if let override = _interval { return override }
				return intervalAppearanceProxy(proxy: mainProxy)
			}
		public var interval: intervalAppearanceProxy {
			get { return self.intervalStyle() }
			set { _interval = newValue }
		}
		open class intervalAppearanceProxy {
			public let mainProxy: () -> CallingBaseStyle
			public init(proxy: @escaping () -> CallingBaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: debug 
			public var _debug: CGFloat?
			open func debugProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _debug { return override }
					return CGFloat(10.0)
				}
			public var debug: CGFloat {
				get { return self.debugProperty() }
				set { _debug = newValue }
			}

			//MARK: long 
			public var _long: CGFloat?
			open func longProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _long { return override }
					return CGFloat(4.34)
				}
			public var long: CGFloat {
				get { return self.longProperty() }
				set { _long = newValue }
			}

			//MARK: tiny 
			public var _tiny: CGFloat?
			open func tinyProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _tiny { return override }
					return CGFloat(1.5)
				}
			public var tiny: CGFloat {
				get { return self.tinyProperty() }
				set { _tiny = newValue }
			}

			//MARK: short 
			public var _short: CGFloat?
			open func shortProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _short { return override }
					return CGFloat(2.34)
				}
			public var short: CGFloat {
				get { return self.shortProperty() }
				set { _short = newValue }
			}

			//MARK: normal 
			public var _normal: CGFloat?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _normal { return override }
					return CGFloat(3.0)
				}
			public var normal: CGFloat {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}
		}

	}
	//MARK: - TimingFunctions
	public var _TimingFunctions: TimingFunctionsAppearanceProxy?
	open func TimingFunctionsStyle() -> TimingFunctionsAppearanceProxy {
		if let override = _TimingFunctions { return override }
			return TimingFunctionsAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
		}
	public var TimingFunctions: TimingFunctionsAppearanceProxy {
		get { return self.TimingFunctionsStyle() }
		set { _TimingFunctions = newValue }
	}
	open class TimingFunctionsAppearanceProxy {
		public let mainProxy: () -> CallingBaseStyle
		public init(proxy: @escaping () -> CallingBaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: easeIn 
		public var _easeIn: AnimationCurveType?
		open func easeInProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> AnimationCurveType {
			if let override = _easeIn { return override }
			return .timingParameters(UICubicTimingParameters(controlPoint1: CGPoint(x: 1.0, y: 0.0), controlPoint2: CGPoint(x: 0.78, y: 1.0)))
			}
		public var easeIn: AnimationCurveType {
			get { return self.easeInProperty() }
			set { _easeIn = newValue }
		}
	}
	//MARK: - Button
	public var _Button: ButtonAppearanceProxy?
	open func ButtonStyle() -> ButtonAppearanceProxy {
		if let override = _Button { return override }
			return ButtonAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
		}
	public var Button: ButtonAppearanceProxy {
		get { return self.ButtonStyle() }
		set { _Button = newValue }
	}
	open class ButtonAppearanceProxy {
		public let mainProxy: () -> CallingBaseStyle
		public init(proxy: @escaping () -> CallingBaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: size 
		public var _size: S.AvatarSize?
		open func sizeProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> S.AvatarSize {
			if let override = _size { return override }
			return S.AvatarSize.smallest
			}
		public var size: S.AvatarSize {
			get { return self.sizeProperty() }
			set { _size = newValue }
		}

		//MARK: textColor 
		public var _textColor: UIColor?
		open func textColorProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _textColor { return override }
			return UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 0.0)
			}
		public var textColor: UIColor {
			get { return self.textColorProperty() }
			set { _textColor = newValue }
		}

		//MARK: mask 
		public var _mask: S.BitMask?
		open func maskProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> S.BitMask {
			if let override = _mask { return override }
			return [S.BitMask.left]
			}
		public var mask: S.BitMask {
			get { return self.maskProperty() }
			set { _mask = newValue }
		}
	}
	//MARK: - Options
	public var _Options: OptionsAppearanceProxy?
	open func OptionsStyle() -> OptionsAppearanceProxy {
		if let override = _Options { return override }
			return OptionsAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
		}
	public var Options: OptionsAppearanceProxy {
		get { return self.OptionsStyle() }
		set { _Options = newValue }
	}
	open class OptionsAppearanceProxy {
		public let mainProxy: () -> CallingBaseStyle
		public init(proxy: @escaping () -> CallingBaseStyle) {
			self.mainProxy = proxy
		}
	}
	//MARK: - ColorButton
	public var _ColorButton: ColorButtonAppearanceProxy?
	open func ColorButtonStyle() -> ColorButtonAppearanceProxy {
		if let override = _ColorButton { return override }
			return ColorButtonAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
		}
	public var ColorButton: ColorButtonAppearanceProxy {
		get { return self.ColorButtonStyle() }
		set { _ColorButton = newValue }
	}
	open class ColorButtonAppearanceProxy: ButtonAppearanceProxy {

		//MARK: size 
		override open func sizeProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> S.AvatarSize {
			if let override = _size { return override }
			return S.AvatarSize.smallest
			}

		//MARK: mask 
		override open func maskProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> S.BitMask {
			if let override = _mask { return override }
			return [S.BitMask.left]
			}

		//MARK: textColor 
		override open func textColorProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _textColor { return override }
			return UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 0.0)
			}
	}
	//MARK: - Animator
	public typealias AnimationCompletion = () -> Void

	public final class AnimationContext: NSObject {
		private(set) public var viewTag: String
		private(set) public var type: AnimationType

		public init(viewTag: String, type: AnimationType) {
			self.viewTag = viewTag
			self.type = type
		}

		public var completion: AnimationCompletion?

		public func animation(of type: AnimationType) -> UIViewPropertyAnimator {
			return animations.last!
		}

		public func add(_ animator: UIViewPropertyAnimator) {
			animator.addCompletion { [weak self] _ in
				guard let `self` = self else { return }
				self.remove(animator)
				if self.animations.count == 0 {
					AnimatorContext.animatorContexts.removeAll(where: { $0 == self })
				}
			}
			animations.append(animator)
		}

		public func remove(_ animator: UIViewPropertyAnimator) {
			animations.removeAll(where: { $0 == animator })
		}

		private var allAnimationsFinished: Bool = true
		private var animations = [UIViewPropertyAnimator]()
		private var lastAnimationStarted: Date?
		private var lastAnimationAborted: Date?

		struct Keys {
			static let animationContextUUID = "UUID"
		}
	}

		public struct AnimatorContext {
			static var animatorContexts = [AnimationContext]()
		}


	public static let Animator = AnimatorAnimatorProxy()
	public class AnimatorAnimatorProxy {
		public func durationAnimation(of type: AnimationType, for view: UIView) -> CGFloat? {
			switch type {
			case .rotate: return view.animator.rotateStyle().durationProperty(view.traitCollection)
			}
		}

		public func curveAnimation(of type: AnimationType, for view: UIView) -> AnimationCurveType? {
			switch type {
			case .rotate: return view.animator.rotateStyle().curveProperty(view.traitCollection)
			}
		}

		public func keyFramesAnimation(of type: AnimationType, for view: UIView) -> [KeyFrame]? {
			switch type {
			case .rotate: return view.animator.rotateStyle().keyFramesProperty(view.traitCollection)
			}
		}

		public func repeatCountAnimation(of type: AnimationType, for view: UIView) -> AnimationRepeatCount? {
			switch type {
			case .rotate: return view.animator.rotateStyle().repeatCountProperty(view.traitCollection)
			}
		}

		public func delayAnimation(of type: AnimationType, for view: UIView) -> CGFloat? {
			switch type {
			case .rotate: return view.animator.rotateStyle().delayProperty(view.traitCollection)
			}
		}

		public func animator(type: AnimationType, for view: UIView, options: AnimationConfigOptions?) -> UIViewPropertyAnimator {
			let duration = options?.duration ?? TimeInterval(durationAnimation(of: type, for: view)!)
			let curve = options?.curve ?? curveAnimation(of: type, for: view)!
			let repeatCount = options?.repeatCount ?? repeatCountAnimation(of: type, for: view)
			let propertyAnimator: UIViewPropertyAnimator
			switch curve {
				case let .native(curve):
					propertyAnimator = UIViewPropertyAnimator(duration: duration, curve: curve)
				case let .timingParameters(curve):
					propertyAnimator = UIViewPropertyAnimator(duration: duration, timingParameters: curve)
			}
			propertyAnimator.repeatCount = repeatCount
			if #available(iOS 11.0, *) {
				propertyAnimator.scrubsLinearly = options?.scrubsLinearly ?? true
			}
			propertyAnimator.addAnimations({ [weak self] in
				UIView.animateKeyframes(withDuration: duration, delay: 0, options: [], animations: {
					guard let `self` = self else { return }
					var keyFrames = self.keyFramesAnimation(of: type, for: view)!
					let onlyRotateValues: (AnimatableProp) -> Bool = { (value) in
						switch value {
						case let .rotate(_, to): return abs(to) > 180
						default: return false
						}
					}
					var normalizedKeyFrames = [KeyFrame]()
					for var keyFrame in keyFrames {
						keyFrame.values.forEach({ (value) in
							switch value {
							case let .rotate(from, to):
								if abs(to) > 180 {
									let split = 3
									let relativeDuration = keyFrame.relativeDuration ?? 1.0
									let relativeStartTime = keyFrame.relativeStartTime
									for i in 0 ..< split {
										let normalizedStartTime = relativeStartTime + (CGFloat(i) / CGFloat(split)) * (relativeDuration - relativeStartTime)
										normalizedKeyFrames.append(KeyFrame(relativeStartTime: normalizedStartTime, relativeDuration: relativeDuration/CGFloat(split), values: [.rotate(from: from, to: to/CGFloat(split))]))
									}
								}
							default: return
							}
						})
						keyFrame.values = keyFrame.values.filter({ onlyRotateValues($0) == false })
					}
					keyFrames = keyFrames + normalizedKeyFrames

					for keyFrame in keyFrames {
						let relativeStartTime = Double(keyFrame.relativeStartTime)
						let relativeDuration = Double(keyFrame.relativeDuration ?? 1.0)
						keyFrame.values.forEach({ $0.applyFrom(to: view) })
						UIView.addKeyframe(withRelativeStartTime: relativeStartTime, relativeDuration: relativeDuration) {
							keyFrame.values.forEach({ $0.applyTo(to: view) })
						}
					}
				})
			})
			if let repeatCount = propertyAnimator.repeatCount, case let .count(count) = repeatCount, count == 0 { return propertyAnimator }
			propertyAnimator.addCompletion({ _ in
				let currentContext = AnimatorContext.animatorContexts.filter({ $0.type == type && $0.viewTag == view.animatorIdentifier }).first

				if let repeatCount = currentContext?.animation(of: type).repeatCount, view.superview != nil && view.window != nil {
					let nextAnimation = self.animator(type: type, for: view, options: options)
					if case let .count(count) = repeatCount {
						let nextCount = count - 1
						nextAnimation.repeatCount = nextCount > 0 ? .count(nextCount) : nil
					}
					if let repeatCount = nextAnimation.repeatCount, case let .count(count) = repeatCount, count == 0 { return }
					nextAnimation.startAnimation()
					currentContext!.add(nextAnimation)
				}
			})
			return propertyAnimator
		}

		public func animate(view: UIView, type: AnimationType, action: AnimationAction = .start, options: AnimationConfigOptions?) {
			let currentContext = AnimatorContext.animatorContexts.filter({ $0.type == type && $0.viewTag == view.animatorIdentifier }).first

			switch action {
			case .start:
				if let animator = currentContext?.animation(of: type) {
					if animator.isRunning == false {
						animator.startAnimation()
					}
					return
				}
				view.animatorIdentifier = UUID().uuidString
				let context = AnimationContext(viewTag: view.animatorIdentifier!, type: type)
				let animation = animator(type: type, for: view, options: options)
				let delay = options?.delay ?? (delayAnimation(of: type, for: view) ?? 0.0)
				animation.startAnimation(afterDelay: TimeInterval(delay))
				context.add(animation)
				AnimatorContext.animatorContexts.append(context)
			case .pause:
				var animation = currentContext?.animation(of: type)
				var fractionComplete: CGFloat?
				if animation != nil && (view.layer.animationKeys() == nil || view.layer.animationKeys()?.count == 0) {
					currentContext?.remove(animation!)
					fractionComplete = animation?.fractionComplete
					animation?.stopAnimation(false)
					animation?.finishAnimation(at: .end)
				}
				if let fractionComplete = fractionComplete {
					view.animatorIdentifier = UUID().uuidString
					let context = AnimationContext(viewTag: view.animatorIdentifier!, type: type)
					animation = animator(type: type, for: view, options: options)
					animation!.fractionComplete = fractionComplete
					context.add(animation!)
					AnimatorContext.animatorContexts.append(context)
				}
				currentContext?.animation(of: type).pauseAnimation()
			case .fractionComplete(let fraction):
				var animation = currentContext?.animation(of: type)
				var shouldRecreate = false
				if animation != nil && (view.layer.animationKeys() == nil || view.layer.animationKeys()?.count == 0) {
					currentContext?.remove(animation!)
					animation?.stopAnimation(false)
					animation?.finishAnimation(at: .end)
					shouldRecreate = true
				}

				if (fraction == 0 && animation == nil) || shouldRecreate {
					view.animatorIdentifier = UUID().uuidString
					let context = AnimationContext(viewTag: view.animatorIdentifier!, type: type)
					animation = animator(type: type, for: view, options: options)
					context.add(animation!)
					AnimatorContext.animatorContexts.append(context)
				}
				if animation!.isRunning { animation?.pauseAnimation() }
				if #available(iOS 11.0, *) {
					animation?.pausesOnCompletion = true
				}
				animation?.fractionComplete = fraction
			case .stop(let withoutFinishing):
				guard let animator = currentContext?.animation(of: type), animator.isRunning else { return }
				animator.stopAnimation(withoutFinishing)
			}
		}

		//MARK: - rotate
		public var _rotate: rotateAppearanceProxy?
		open func rotateStyle() -> rotateAppearanceProxy {
			if let override = _rotate { return override }
				return rotateAppearanceProxy(proxy: { return CallingBaseStyle.shared() })
			}
		public var rotate: rotateAppearanceProxy {
			get { return self.rotateStyle() }
			set { _rotate = newValue }
		}
		open class rotateAppearanceProxy {
			public let mainProxy: () -> CallingBaseStyle
			public init(proxy: @escaping () -> CallingBaseStyle) {
				self.mainProxy = proxy
			}

		//MARK: repeatCount 
		public var _repeatCount: AnimationRepeatCount?
		open func repeatCountProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> AnimationRepeatCount {
			if let override = _repeatCount { return override }
			return AnimationRepeatCount.count(0)
			}
		public var repeatCount: AnimationRepeatCount {
			get { return self.repeatCountProperty() }
			set { _repeatCount = newValue }
		}

		//MARK: curve 
		public var _curve: AnimationCurveType?
		open func curveProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> AnimationCurveType {
			if let override = _curve { return override }
			return mainProxy().TimingFunctions.easeInProperty(traitCollection)
			}
		public var curve: AnimationCurveType {
			get { return self.curveProperty() }
			set { _curve = newValue }
		}

		//MARK: delay 
		public var _delay: CGFloat?
		open func delayProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
			if let override = _delay { return override }
			return CGFloat(0.0)
			}
		public var delay: CGFloat {
			get { return self.delayProperty() }
			set { _delay = newValue }
		}

		//MARK: keyFrames 
		public var _keyFrames: [KeyFrame]?
		open func keyFramesProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> [KeyFrame] {
			if let override = _keyFrames { return override }
			return [
			KeyFrame(relativeStartTime: 0.0, relativeDuration: nil, values: 
			[
			.rotate(from: 
			CGFloat(0.0), to: 
			CGFloat(360.0))])]
			}
		public var keyFrames: [KeyFrame] {
			get { return self.keyFramesProperty() }
			set { _keyFrames = newValue }
		}

		//MARK: duration 
		public var _duration: CGFloat?
		open func durationProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
			if let override = _duration { return override }
			return mainProxy().Duration.interval.longProperty(traitCollection)
			}
		public var duration: CGFloat {
			get { return self.durationProperty() }
			set { _duration = newValue }
		}
		}
	

}
}
extension Button: AppearaceProxyComponent {

	public typealias ApperanceProxyType = CallingBaseStyle.ButtonAppearanceProxy
	public var appearanceProxy: ApperanceProxyType {
		get {
			if let proxy = objc_getAssociatedObject(self, &__ApperanceProxyHandle) as? ApperanceProxyType {
				if !themeAware { return proxy }

				if proxy is CallingBaseStyle.ColorButtonAppearanceProxy {
					return StylesheetManager.stylesheet(CallingBaseStyle.shared()).ColorButton
				}
				return proxy
			}

			return StylesheetManager.stylesheet(CallingBaseStyle.shared()).Button
		}
		set {
			objc_setAssociatedObject(self, &__ApperanceProxyHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
			didChangeAppearanceProxy()
		}
	}

	public var themeAware: Bool {
		get {
			guard let proxy = objc_getAssociatedObject(self, &__ThemeAwareHandle) as? Bool else { return true }
			return proxy
		}
		set {
			objc_setAssociatedObject(self, &__ThemeAwareHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
			isObservingDidChangeTheme = newValue
		}
	}

	fileprivate var isObservingDidChangeTheme: Bool {
		get {
			guard let observing = objc_getAssociatedObject(self, &__ObservingDidChangeThemeHandle) as? Bool else { return false }
			return observing
		}
		set {
			if newValue == isObservingDidChangeTheme { return }
			if newValue {
				NotificationCenter.default.addObserver(self, selector: #selector(didChangeAppearanceProxy), name: Notification.Name.didChangeTheme, object: nil)
			} else {
				NotificationCenter.default.removeObserver(self, name: Notification.Name.didChangeTheme, object: nil)
			}
			objc_setAssociatedObject(self, &__ObservingDidChangeThemeHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
		}
	}
}

extension UIViewPropertyAnimator {

	public var repeatCount: AnimationRepeatCount? {
		get {
			guard let count = objc_getAssociatedObject(self, &__AnimatorRepeatCountHandle) as? AnimationRepeatCount else { return nil }
			return count
		}
		set { objc_setAssociatedObject(self, &__AnimatorRepeatCountHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}
}

extension UIView: AnimatorProxyComponent {

	public var animatorIdentifier: String? {
		get {
			guard let identifier = objc_getAssociatedObject(self, &__AnimatorIdentifierHandle) as? String else { return nil }
			return identifier
		}
		set { objc_setAssociatedObject(self, &__AnimatorIdentifierHandle, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC) }
	}

	public typealias AnimatorProxyType = CallingBaseStyle.AnimatorAnimatorProxy
	public var animator: AnimatorProxyType {
		get {
			guard let a = objc_getAssociatedObject(self, &__AnimatorProxyHandle) as? AnimatorProxyType else { return CallingBaseStyle.Animator }
			return a
		}
		set { objc_setAssociatedObject(self, &__AnimatorProxyHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}

	public func rotate(action: AnimationAction = .start, options: AnimationConfigOptions? = nil) {
		animator.animate(view: self, type: .rotate, action: action, options: options)
	}

}
