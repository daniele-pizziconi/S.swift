/// Autogenerated file

// swiftlint:disable all
import UIKit

public enum Theme: Int {
	case teams
	case base
	case skype

	public var stylesheet: BaseStyle {
		switch self {
		case .teams: return TeamsStyle.shared()
		case .base: return BaseStyle.shared()
		case .skype: return SkypeStyle.shared()
		}
	}
}

public class StyleManager {
	@objc dynamic public class func stylesheet(_ stylesheet: BaseStyle) -> BaseStyle {
		return StyleManager.default.theme.stylesheet
	}

	public static let `default` = StyleManager()
	public static var S: BaseStyle {
		return StyleManager.default.theme.stylesheet
	}

	public var theme: Theme {
		switch StylesheetManager.default.theme {
		case .teams: return .teams
		case .skype: return .skype
		case .base: return .base
		}
	}

}

public class Application {
	@objc dynamic public class func preferredContentSizeCategory() -> UIContentSizeCategory {
		return .large
	}
}

fileprivate var __ApperanceProxyHandle: UInt8 = 0
fileprivate var __ThemeAwareHandle: UInt8 = 0
fileprivate var __ObservingDidChangeThemeHandle: UInt8 = 0

/// Your view should conform to 'AppearaceProxyComponent'.
public protocol AppearaceProxyComponent: class {
	associatedtype ApperanceProxyType
	var appearanceProxy: ApperanceProxyType { get }
	var themeAware: Bool { get set }
	func didChangeAppearanceProxy()
}

public extension AppearaceProxyComponent {
	public func initAppearanceProxy(themeAware: Bool = true) {
		self.themeAware = themeAware
		didChangeAppearanceProxy()
	}
}

#if os(iOS)
private let defaultSizes: [UIFont.TextStyle: CGFloat] = {
	var sizes: [UIFont.TextStyle: CGFloat] = [.caption2: 11,
	.caption1: 12,
	.footnote: 13,
	.subheadline: 15,
	.callout: 16,
	.body: 17,
	.headline: 17,
	.title3: 20,
	.title2: 22,
	.title1: 28]
	if #available(iOS 11.0, *) {
		sizes[.largeTitle] = 34
	}
	return sizes
}()
#elseif os(tvOS)
private let defaultSizes: [UIFont.TextStyle: CGFloat] =
	[.caption2: 23,
		.caption1: 25,
		.footnote: 29,
		.subheadline: 29,
		.body: 29,
		.callout: 31,
		.headline: 38,
		.title3: 48,
		.title2: 57,
		.title1: 76]
#elseif os(tvOS)
private let defaultSizes: [UIFont.TextStyle: CGFloat] = {
	if #available(watchOS 5.0, *) {
		switch WKInterfaceDevice.current().preferredContentSizeCategory {
		case "UICTContentSizeCategoryS":
			return [.footnote: 12,
				.caption2: 13,
				.caption1: 14,
				.body: 15,
				.headline: 15,
				.title3: 18,
				.title2: 26,
				.title1: 30,
				.largeTitle: 32]
		case "UICTContentSizeCategoryL":
			return [.footnote: 13,
				.caption2: 14,
				.caption1: 15,
				.body: 16,
				.headline: 16,
				.title3: 19,
				.title2: 27,
				.title1: 34,
				.largeTitle: 36]
		case "UICTContentSizeCategoryXL":
			return [.footnote: 14,
				.caption2: 15,
				.caption1: 16,
				.body: 17,
				.headline: 17,
				.title3: 20,
				.title2: 30,
				.title1: 38,
				.largeTitle: 40]
		default:
			return [:]
		}
	} else {
		/// No `largeTitle` before watchOS 5
		switch WKInterfaceDevice.current().preferredContentSizeCategory {
		case "UICTContentSizeCategoryS":
			return [.footnote: 12,
					.caption2: 13,
					.caption1: 14,
					.body: 15,
					.headline: 15,
					.title3: 18,
					.title2: 26,
					.title1: 30]
		case "UICTContentSizeCategoryL":
			return [.footnote: 13,
					.caption2: 14,
					.caption1: 15,
					.body: 16,
					.headline: 16,
					.title3: 19,
					.title2: 27,
					.title1: 34]
		default:
			return [:]
		}
	}
}()
#endif

fileprivate var __ScalableHandle: UInt8 = 0
public extension UIFont {
	static func scaledFont(name: String, textStyle: UIFont.TextStyle, traitCollection: UITraitCollection? = nil) -> UIFont {
		if #available(iOS 11.0, *) {
			guard let defaultSize = defaultSizes[textStyle], let customFont = UIFont(name: name, size: defaultSize) else {
				fatalError("Failed to load the \(name) font.")
			}
			return UIFontMetrics(forTextStyle: textStyle).scaledFont(for: customFont, compatibleWith: traitCollection)
		} else {
			let fontDescriptor = UIFontDescriptor.preferredFontDescriptor(withTextStyle: textStyle, compatibleWith: traitCollection)
			guard let customFont = UIFont(name: name, size: fontDescriptor.pointSize) else {
				fatalError("Failed to load the \(name) font.")
			}
			return customFont
		}
	}

	public func with(traits: UIFontDescriptor.SymbolicTraits) -> UIFont {
		let descriptor = fontDescriptor.withSymbolicTraits(traits)
		return UIFont(descriptor: descriptor!, size: 0)
	}

	public class func preferredFont(forTextStyle style: UIFont.TextStyle, compatibleWith traitCollection: UITraitCollection?, scalable: Bool) -> UIFont {
		let font = UIFont.preferredFont(forTextStyle: style, compatibleWith: traitCollection)
		font.isScalable = true
		return font
	}

	public convenience init?(name: String, scalable: Bool) {
		self.init(name: name, size: 4)
		self.isScalable = scalable
	}

	public var isScalable: Bool {
		get { return objc_getAssociatedObject(self, &__ScalableHandle) as? Bool ?? false }
		set { objc_setAssociatedObject(self, &__ScalableHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}

}

fileprivate var __AnimatorProxyHandle: UInt8 = 0
fileprivate var __AnimatorRepeatCountHandle: UInt8 = 0
fileprivate var __AnimatorIdentifierHandle: UInt8 = 0

/// Your view should conform to 'AnimatorProxyComponent'.
public protocol AnimatorProxyComponent: class {
	associatedtype AnimatorProxyType
	var animator: AnimatorProxyType { get }

}


public struct KeyFrame {
	var relativeStartTime: CGFloat
	var relativeDuration: CGFloat?
	var values: [AnimatableProp]
}

public enum AnimationAction {
	case start
	case pause
	case stop(withoutFinishing: Bool)
	case fractionComplete(CGFloat)
}

public struct AnimationConfigOptions {
	let repeatCount: AnimationRepeatCount?
	let delay: CGFloat?
	let duration: TimeInterval?
	let curve: AnimationCurveType?
	let scrubsLinearly: Bool?

	public init(duration: TimeInterval? = nil, delay: CGFloat? = nil, repeatCount: AnimationRepeatCount? = nil, curve: AnimationCurveType? = nil, scrubsLinearly: Bool? = nil) {
		self.duration = duration
		self.delay = delay
		self.repeatCount = repeatCount
		self.curve = curve
		self.scrubsLinearly = scrubsLinearly
	}
}

public enum AnimationRepeatCount {
	case infinite
	case count(Int)
}

public enum AnimationCurveType {
	case native(UIView.AnimationCurve)
	case timingParameters(UITimingCurveProvider)
}

public enum AnimationType {
	case rotate
}

public enum AnimatableProp: Equatable {
	case opacity(from: CGFloat?, to: CGFloat)
	case frame(from: CGRect?, to: CGRect)
	case size(from: CGSize?, to: CGSize)
	case width(from: CGFloat?, to: CGFloat)
	case height(from: CGFloat?, to: CGFloat)
	case left(from: CGFloat?, to: CGFloat)
	case rotate(from: CGFloat?, to: CGFloat)
}


public extension AnimatableProp {
	func applyFrom(to view: UIView) {
		switch self {
		case .opacity(let from, _):	if let from = from { view.alpha = from }
		case .frame(let from, _):	if let from = from { view.frame = from }
		case .size(let from, _):	if let from = from { view.bounds.size = from }
		case .width(let from, _):	if let from = from { view.bounds.size.width = from }
		case .height(let from, _):	if let from = from { view.bounds.size.height = from }
		case .left(let from, _):	if let from = from { view.frame.origin.x = from }
		case .rotate(let from, _):	if let from = from { view.transform = view.transform.rotated(by: (from * .pi / 180.0)) }
		}
	}

	func applyTo(to view: UIView) {
		switch self {
		case .opacity(_, let to):	view.alpha = to
		case .frame(_, let to):		view.frame = to
		case .size(_, let to):		view.bounds.size = to
		case .width(_, let to):		view.bounds.size.width = to
		case .height(_, let to):	view.bounds.size.height = to
		case .left(_, let to):		view.frame.origin.x = to
		case .rotate(_, let to):	view.transform = view.transform.rotated(by: (to * .pi / 180.0))
		}
	}

}

/// Entry point for the app stylesheet
public class BaseStyle: NSObject {

	public class func shared() -> BaseStyle {
		 struct __ { static let _sharedInstance = BaseStyle() }
		return __._sharedInstance
	}
	//MARK: - Typography
	public var _Typography: TypographyAppearanceProxy?
	open func TypographyStyle() -> TypographyAppearanceProxy {
		if let override = _Typography { return override }
			return TypographyAppearanceProxy(proxy: { return BaseStyle.shared() })
		}
	public var Typography: TypographyAppearanceProxy {
		get { return self.TypographyStyle() }
		set { _Typography = newValue }
	}
	open class TypographyAppearanceProxy {
		public let mainProxy: () -> BaseStyle
		public init(proxy: @escaping () -> BaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: - textStyles
		public var _textStyles: textStylesAppearanceProxy?
		open func textStylesStyle() -> textStylesAppearanceProxy {
			if let override = _textStyles { return override }
				return textStylesAppearanceProxy(proxy: mainProxy)
			}
		public var textStyles: textStylesAppearanceProxy {
			get { return self.textStylesStyle() }
			set { _textStyles = newValue }
		}
		open class textStylesAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: title2 
			public var _title2: UIFont?
			open func title2Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIFont {
				if let override = _title2 { return override }
					return UIFont.scaledFont(name: "Menlo", textStyle: UIFont.TextStyle.body, traitCollection: traitCollection).with(traits: [UIFontDescriptor.SymbolicTraits.traitBold])
				}
			public var title2: UIFont {
				get { return self.title2Property() }
				set { _title2 = newValue }
			}

			//MARK: title1 
			public var _title1: UIFont?
			open func title1Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIFont {
				if let override = _title1 { return override }
					return UIFont.preferredFont(forTextStyle: UIFont.TextStyle.body, compatibleWith: traitCollection, scalable: true)
				}
			public var title1: UIFont {
				get { return self.title1Property() }
				set { _title1 = newValue }
			}
		}

	}
	//MARK: - Duration
	public var _Duration: DurationAppearanceProxy?
	open func DurationStyle() -> DurationAppearanceProxy {
		if let override = _Duration { return override }
			return DurationAppearanceProxy(proxy: { return BaseStyle.shared() })
		}
	public var Duration: DurationAppearanceProxy {
		get { return self.DurationStyle() }
		set { _Duration = newValue }
	}
	open class DurationAppearanceProxy {
		public let mainProxy: () -> BaseStyle
		public init(proxy: @escaping () -> BaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: - interval
		public var _interval: intervalAppearanceProxy?
		open func intervalStyle() -> intervalAppearanceProxy {
			if let override = _interval { return override }
				return intervalAppearanceProxy(proxy: mainProxy)
			}
		public var interval: intervalAppearanceProxy {
			get { return self.intervalStyle() }
			set { _interval = newValue }
		}
		open class intervalAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: tiny 
			public var _tiny: CGFloat?
			open func tinyProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _tiny { return override }
					return CGFloat(1.5)
				}
			public var tiny: CGFloat {
				get { return self.tinyProperty() }
				set { _tiny = newValue }
			}

			//MARK: long 
			public var _long: CGFloat?
			open func longProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _long { return override }
					return CGFloat(4.34)
				}
			public var long: CGFloat {
				get { return self.longProperty() }
				set { _long = newValue }
			}

			//MARK: normal 
			public var _normal: CGFloat?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _normal { return override }
					return CGFloat(3.0)
				}
			public var normal: CGFloat {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: debug 
			public var _debug: CGFloat?
			open func debugProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _debug { return override }
					return CGFloat(10.0)
				}
			public var debug: CGFloat {
				get { return self.debugProperty() }
				set { _debug = newValue }
			}

			//MARK: short 
			public var _short: CGFloat?
			open func shortProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
				if let override = _short { return override }
					return CGFloat(2.34)
				}
			public var short: CGFloat {
				get { return self.shortProperty() }
				set { _short = newValue }
			}
		}

	}
	//MARK: - Button
	public var _Button: ButtonAppearanceProxy?
	open func ButtonStyle() -> ButtonAppearanceProxy {
		if let override = _Button { return override }
			return ButtonAppearanceProxy(proxy: { return BaseStyle.shared() })
		}
	public var Button: ButtonAppearanceProxy {
		get { return self.ButtonStyle() }
		set { _Button = newValue }
	}
	open class ButtonAppearanceProxy {
		public let mainProxy: () -> BaseStyle
		public init(proxy: @escaping () -> BaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: - color
		public var _color: colorAppearanceProxy?
		open func colorStyle() -> colorAppearanceProxy {
			if let override = _color { return override }
				return colorAppearanceProxy(proxy: mainProxy)
			}
		public var color: colorAppearanceProxy {
			get { return self.colorStyle() }
			set { _color = newValue }
		}
		open class colorAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: disabled 
			public var _disabled: UIColor?
			open func disabledProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _disabled { return override }
					return mainProxy().Color.gray.g06Property(traitCollection)
				}
			public var disabled: UIColor {
				get { return self.disabledProperty() }
				set { _disabled = newValue }
			}

			//MARK: normal 
			public var _normal: UIColor?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _normal { return override }
					return mainProxy().Color.black.normalProperty(traitCollection)
				}
			public var normal: UIColor {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: activeDisabled 
			public var _activeDisabled: UIColor?
			open func activeDisabledProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _activeDisabled { return override }
					return mainProxy().Color.black.normalProperty(traitCollection)
				}
			public var activeDisabled: UIColor {
				get { return self.activeDisabledProperty() }
				set { _activeDisabled = newValue }
			}

			//MARK: hover 
			public var _hover: UIColor?
			open func hoverProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _hover { return override }
					return mainProxy().Color.black.normalProperty(traitCollection)
				}
			public var hover: UIColor {
				get { return self.hoverProperty() }
				set { _hover = newValue }
			}

			//MARK: active 
			public var _active: UIColor?
			open func activeProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _active { return override }
					return mainProxy().Color.black.normalProperty(traitCollection)
				}
			public var active: UIColor {
				get { return self.activeProperty() }
				set { _active = newValue }
			}

			//MARK: focus 
			public var _focus: UIColor?
			open func focusProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _focus { return override }
					return mainProxy().Color.black.normalProperty(traitCollection)
				}
			public var focus: UIColor {
				get { return self.focusProperty() }
				set { _focus = newValue }
			}
		}

	}
	//MARK: - Color
	public var _Color: ColorAppearanceProxy?
	open func ColorStyle() -> ColorAppearanceProxy {
		if let override = _Color { return override }
			return ColorAppearanceProxy(proxy: { return BaseStyle.shared() })
		}
	public var Color: ColorAppearanceProxy {
		get { return self.ColorStyle() }
		set { _Color = newValue }
	}
	open class ColorAppearanceProxy {
		public let mainProxy: () -> BaseStyle
		public init(proxy: @escaping () -> BaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: white 
		public var _white: UIColor?
		open func whiteProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _white { return override }
			return UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1.0)
			}
		public var white: UIColor {
			get { return self.whiteProperty() }
			set { _white = newValue }
		}

		//MARK: - gray
		public var _gray: grayAppearanceProxy?
		open func grayStyle() -> grayAppearanceProxy {
			if let override = _gray { return override }
				return grayAppearanceProxy(proxy: mainProxy)
			}
		public var gray: grayAppearanceProxy {
			get { return self.grayStyle() }
			set { _gray = newValue }
		}
		open class grayAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: g14 
			public var _g14: UIColor?
			open func g14Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g14 { return override }
					return UIColor(red: 0.98039216, green: 0.9764706, blue: 0.972549, alpha: 1.0)
				}
			public var g14: UIColor {
				get { return self.g14Property() }
				set { _g14 = newValue }
			}

			//MARK: g04 
			public var _g04: UIColor?
			open func g04Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g04 { return override }
					return UIColor(red: 0.5921569, green: 0.58431375, blue: 0.5764706, alpha: 1.0)
				}
			public var g04: UIColor {
				get { return self.g04Property() }
				set { _g04 = newValue }
			}

			//MARK: g09 
			public var _g09: UIColor?
			open func g09Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g09 { return override }
					return UIColor(red: 0.92941177, green: 0.92156863, blue: 0.9137255, alpha: 1.0)
				}
			public var g09: UIColor {
				get { return self.g09Property() }
				set { _g09 = newValue }
			}

			//MARK: g02 
			public var _g02: UIColor?
			open func g02Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g02 { return override }
					return UIColor(red: 0.28235295, green: 0.27450982, blue: 0.26666668, alpha: 1.0)
				}
			public var g02: UIColor {
				get { return self.g02Property() }
				set { _g02 = newValue }
			}

			//MARK: g08 
			public var _g08: UIColor?
			open func g08Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g08 { return override }
					return UIColor(red: 0.88235295, green: 0.8745098, blue: 0.8666667, alpha: 1.0)
				}
			public var g08: UIColor {
				get { return self.g08Property() }
				set { _g08 = newValue }
			}

			//MARK: g03 
			public var _g03: UIColor?
			open func g03Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g03 { return override }
					return UIColor(red: 0.3764706, green: 0.36862746, blue: 0.36078432, alpha: 1.0)
				}
			public var g03: UIColor {
				get { return self.g03Property() }
				set { _g03 = newValue }
			}

			//MARK: g06 
			public var _g06: UIColor?
			open func g06Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g06 { return override }
					return UIColor(red: 0.78431374, green: 0.7764706, blue: 0.76862746, alpha: 1.0)
				}
			public var g06: UIColor {
				get { return self.g06Property() }
				set { _g06 = newValue }
			}

			//MARK: g10 
			public var _g10: UIColor?
			open func g10Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g10 { return override }
					return UIColor(red: 0.9529412, green: 0.9490196, blue: 0.94509804, alpha: 1.0)
				}
			public var g10: UIColor {
				get { return self.g10Property() }
				set { _g10 = newValue }
			}
		}


		//MARK: orange04 
		public var _orange04: UIColor?
		open func orange04Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _orange04 { return override }
			return UIColor(red: 0.8, green: 0.2901961, blue: 0.19215687, alpha: 1.0)
			}
		public var orange04: UIColor {
			get { return self.orange04Property() }
			set { _orange04 = newValue }
		}

		//MARK: - black
		public var _black: blackAppearanceProxy?
		open func blackStyle() -> blackAppearanceProxy {
			if let override = _black { return override }
				return blackAppearanceProxy(proxy: mainProxy)
			}
		public var black: blackAppearanceProxy {
			get { return self.blackStyle() }
			set { _black = newValue }
		}
		open class blackAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: overlayLight 
			public var _overlayLight: UIColor?
			open func overlayLightProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _overlayLight { return override }
					return UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.1882353)
				}
			public var overlayLight: UIColor {
				get { return self.overlayLightProperty() }
				set { _overlayLight = newValue }
			}

			//MARK: overlay 
			public var _overlay: UIColor?
			open func overlayProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _overlay { return override }
					return UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.4392157)
				}
			public var overlay: UIColor {
				get { return self.overlayProperty() }
				set { _overlay = newValue }
			}

			//MARK: border 
			public var _border: UIColor?
			open func borderProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _border { return override }
					return UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.1254902)
				}
			public var border: UIColor {
				get { return self.borderProperty() }
				set { _border = newValue }
			}

			//MARK: normal 
			public var _normal: UIColor?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _normal { return override }
					return UIColor(red: 0.14509805, green: 0.14117648, blue: 0.13725491, alpha: 1.0)
				}
			public var normal: UIColor {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: overlayMid 
			public var _overlayMid: UIColor?
			open func overlayMidProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _overlayMid { return override }
					return UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.3137255)
				}
			public var overlayMid: UIColor {
				get { return self.overlayMidProperty() }
				set { _overlayMid = newValue }
			}
		}


		//MARK: - red
		public var _red: redAppearanceProxy?
		open func redStyle() -> redAppearanceProxy {
			if let override = _red { return override }
				return redAppearanceProxy(proxy: mainProxy)
			}
		public var red: redAppearanceProxy {
			get { return self.redStyle() }
			set { _red = newValue }
		}
		open class redAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: normal 
			public var _normal: UIColor?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _normal { return override }
					return UIColor(red: 0.76862746, green: 0.19215687, blue: 0.29411766, alpha: 1.0)
				}
			public var normal: UIColor {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: r08 
			public var _r08: UIColor?
			open func r08Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _r08 { return override }
					return UIColor(red: 0.9529412, green: 0.8392157, blue: 0.85882354, alpha: 1.0)
				}
			public var r08: UIColor {
				get { return self.r08Property() }
				set { _r08 = newValue }
			}
		}


		//MARK: magenta 
		public var _magenta: UIColor?
		open func magentaProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _magenta { return override }
			return UIColor(red: 0.69803923, green: 0.2784314, blue: 0.50980395, alpha: 1.0)
			}
		public var magenta: UIColor {
			get { return self.magentaProperty() }
			set { _magenta = newValue }
		}

		//MARK: - green
		public var _green: greenAppearanceProxy?
		open func greenStyle() -> greenAppearanceProxy {
			if let override = _green { return override }
				return greenAppearanceProxy(proxy: mainProxy)
			}
		public var green: greenAppearanceProxy {
			get { return self.greenStyle() }
			set { _green = newValue }
		}
		open class greenAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: normal 
			public var _normal: UIColor?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _normal { return override }
					return UIColor(red: 0.57254905, green: 0.7647059, blue: 0.3254902, alpha: 1.0)
				}
			public var normal: UIColor {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: g04 
			public var _g04: UIColor?
			open func g04Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _g04 { return override }
					return UIColor(red: 0.13725491, green: 0.48235294, blue: 0.29411766, alpha: 1.0)
				}
			public var g04: UIColor {
				get { return self.g04Property() }
				set { _g04 = newValue }
			}
		}


		//MARK: yellow 
		public var _yellow: UIColor?
		open func yellowProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _yellow { return override }
			return UIColor(red: 0.972549, green: 0.8235294, blue: 0.16470589, alpha: 1.0)
			}
		public var yellow: UIColor {
			get { return self.yellowProperty() }
			set { _yellow = newValue }
		}

		//MARK: orchid 
		public var _orchid: UIColor?
		open func orchidProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _orchid { return override }
			return UIColor(red: 0.5803922, green: 0.21176471, blue: 0.4392157, alpha: 1.0)
			}
		public var orchid: UIColor {
			get { return self.orchidProperty() }
			set { _orchid = newValue }
		}

		//MARK: - brand
		public var _brand: brandAppearanceProxy?
		open func brandStyle() -> brandAppearanceProxy {
			if let override = _brand { return override }
				return brandAppearanceProxy(proxy: mainProxy)
			}
		public var brand: brandAppearanceProxy {
			get { return self.brandStyle() }
			set { _brand = newValue }
		}
		open class brandAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

			//MARK: b04 
			public var _b04: UIColor?
			open func b04Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b04 { return override }
					return UIColor(red: 0.27450982, green: 0.2784314, blue: 0.45882353, alpha: 1.0)
				}
			public var b04: UIColor {
				get { return self.b04Property() }
				set { _b04 = newValue }
			}

			//MARK: b16 
			public var _b16: UIColor?
			open func b16Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b16 { return override }
					return UIColor(red: 0.95686275, green: 0.95686275, blue: 0.9882353, alpha: 1.0)
				}
			public var b16: UIColor {
				get { return self.b16Property() }
				set { _b16 = newValue }
			}

			//MARK: b02 
			public var _b02: UIColor?
			open func b02Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b02 { return override }
					return UIColor(red: 0.2, green: 0.20392157, blue: 0.2901961, alpha: 1.0)
				}
			public var b02: UIColor {
				get { return self.b02Property() }
				set { _b02 = newValue }
			}

			//MARK: b06 
			public var _b06: UIColor?
			open func b06Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b06 { return override }
					return UIColor(red: 0.38431373, green: 0.39215687, blue: 0.654902, alpha: 1.0)
				}
			public var b06: UIColor {
				get { return self.b06Property() }
				set { _b06 = newValue }
			}

			//MARK: normal 
			public var _normal: UIColor?
			open func normalProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _normal { return override }
					return UIColor(red: 0.38431373, green: 0.39215687, blue: 0.654902, alpha: 1.0)
				}
			public var normal: UIColor {
				get { return self.normalProperty() }
				set { _normal = newValue }
			}

			//MARK: b12 
			public var _b12: UIColor?
			open func b12Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b12 { return override }
					return UIColor(red: 0.7411765, green: 0.7411765, blue: 0.9019608, alpha: 1.0)
				}
			public var b12: UIColor {
				get { return self.b12Property() }
				set { _b12 = newValue }
			}

			//MARK: b14 
			public var _b14: UIColor?
			open func b14Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b14 { return override }
					return UIColor(red: 0.8862745, green: 0.8862745, blue: 0.9647059, alpha: 1.0)
				}
			public var b14: UIColor {
				get { return self.b14Property() }
				set { _b14 = newValue }
			}

			//MARK: b08 
			public var _b08: UIColor?
			open func b08Property(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
				if let override = _b08 { return override }
					return UIColor(red: 0.54509807, green: 0.54901963, blue: 0.78039217, alpha: 1.0)
				}
			public var b08: UIColor {
				get { return self.b08Property() }
				set { _b08 = newValue }
			}
		}


		//MARK: transparent 
		public var _transparent: UIColor?
		open func transparentProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _transparent { return override }
			return UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 0.0)
			}
		public var transparent: UIColor {
			get { return self.transparentProperty() }
			set { _transparent = newValue }
		}
	}
	//MARK: - TimingFunctions
	public var _TimingFunctions: TimingFunctionsAppearanceProxy?
	open func TimingFunctionsStyle() -> TimingFunctionsAppearanceProxy {
		if let override = _TimingFunctions { return override }
			return TimingFunctionsAppearanceProxy(proxy: { return BaseStyle.shared() })
		}
	public var TimingFunctions: TimingFunctionsAppearanceProxy {
		get { return self.TimingFunctionsStyle() }
		set { _TimingFunctions = newValue }
	}
	open class TimingFunctionsAppearanceProxy {
		public let mainProxy: () -> BaseStyle
		public init(proxy: @escaping () -> BaseStyle) {
			self.mainProxy = proxy
		}

		//MARK: easeIn 
		public var _easeIn: AnimationCurveType?
		open func easeInProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> AnimationCurveType {
			if let override = _easeIn { return override }
			return .timingParameters(UICubicTimingParameters(controlPoint1: CGPoint(x: 1.0, y: 0.0), controlPoint2: CGPoint(x: 0.78, y: 1.0)))
			}
		public var easeIn: AnimationCurveType {
			get { return self.easeInProperty() }
			set { _easeIn = newValue }
		}
	}
	//MARK: - Animator
	public typealias AnimationCompletion = () -> Void

	public final class AnimationContext: NSObject {
		private(set) public var viewTag: String
		private(set) public var type: AnimationType

		public init(viewTag: String, type: AnimationType) {
			self.viewTag = viewTag
			self.type = type
		}

		public var completion: AnimationCompletion?

		public func animation(of type: AnimationType) -> UIViewPropertyAnimator {
			return animations.last!
		}

		public func add(_ animator: UIViewPropertyAnimator) {
			animator.addCompletion { [weak self] _ in
				guard let `self` = self else { return }
				self.remove(animator)
				if self.animations.count == 0 {
					AnimatorContext.animatorContexts.removeAll(where: { $0 == self })
				}
			}
			animations.append(animator)
		}

		public func remove(_ animator: UIViewPropertyAnimator) {
			animations.removeAll(where: { $0 == animator })
		}

		private var allAnimationsFinished: Bool = true
		private var animations = [UIViewPropertyAnimator]()
		private var lastAnimationStarted: Date?
		private var lastAnimationAborted: Date?

		struct Keys {
			static let animationContextUUID = "UUID"
		}
	}

		public struct AnimatorContext {
			static var animatorContexts = [AnimationContext]()
		}


	public var _Animator: AnimatorAnimatorProxy?
	open func AnimatorAnimator() -> AnimatorAnimatorProxy {
		if let override = _Animator { return override }
			return AnimatorAnimatorProxy()
		}
	public var Animator: AnimatorAnimatorProxy {
		get { return self.AnimatorAnimator() }
		set { _Animator = newValue }
	}
	open class AnimatorAnimatorProxy {
		public init() {}
		open func durationAnimation(of type: AnimationType, for view: UIView) -> CGFloat? {
			switch type {
			case .rotate: return view.animator.rotateStyle().durationProperty(view.traitCollection)
			}
		}

		open func curveAnimation(of type: AnimationType, for view: UIView) -> AnimationCurveType? {
			switch type {
			case .rotate: return view.animator.rotateStyle().curveProperty(view.traitCollection)
			}
		}

		open func keyFramesAnimation(of type: AnimationType, for view: UIView) -> [KeyFrame]? {
			switch type {
			case .rotate: return view.animator.rotateStyle().keyFramesProperty(view.traitCollection)
			}
		}

		open func repeatCountAnimation(of type: AnimationType, for view: UIView) -> AnimationRepeatCount? {
			switch type {
			case .rotate: return view.animator.rotateStyle().repeatCountProperty(view.traitCollection)
			}
		}

		open func delayAnimation(of type: AnimationType, for view: UIView) -> CGFloat? {
			switch type {
			case .rotate: return view.animator.rotateStyle().delayProperty(view.traitCollection)
			}
		}

		open func animator(type: AnimationType, for view: UIView, options: AnimationConfigOptions?) -> UIViewPropertyAnimator {
			let duration = options?.duration ?? TimeInterval(durationAnimation(of: type, for: view)!)
			let curve = options?.curve ?? curveAnimation(of: type, for: view)!
			let repeatCount = options?.repeatCount ?? repeatCountAnimation(of: type, for: view)
			let propertyAnimator: UIViewPropertyAnimator
			switch curve {
				case let .native(curve):
					propertyAnimator = UIViewPropertyAnimator(duration: duration, curve: curve)
				case let .timingParameters(curve):
					propertyAnimator = UIViewPropertyAnimator(duration: duration, timingParameters: curve)
			}
			propertyAnimator.repeatCount = repeatCount
			if #available(iOS 11.0, *) {
				propertyAnimator.scrubsLinearly = options?.scrubsLinearly ?? true
			}
			propertyAnimator.addAnimations({ [weak self] in
				UIView.animateKeyframes(withDuration: duration, delay: 0, options: [], animations: {
					guard let `self` = self else { return }
					var keyFrames = self.keyFramesAnimation(of: type, for: view)!
					let onlyRotateValues: (AnimatableProp) -> Bool = { (value) in
						switch value {
						case let .rotate(_, to): return abs(to) > 180
						default: return false
						}
					}
					var normalizedKeyFrames = [KeyFrame]()
					for var keyFrame in keyFrames {
						keyFrame.values.forEach({ (value) in
							switch value {
							case let .rotate(from, to):
								if abs(to) > 180 {
									let split = 3
									let relativeDuration = keyFrame.relativeDuration ?? 1.0
									let relativeStartTime = keyFrame.relativeStartTime
									for i in 0 ..< split {
										let normalizedStartTime = relativeStartTime + (CGFloat(i) / CGFloat(split)) * (relativeDuration - relativeStartTime)
										normalizedKeyFrames.append(KeyFrame(relativeStartTime: normalizedStartTime, relativeDuration: relativeDuration/CGFloat(split), values: [.rotate(from: from, to: to/CGFloat(split))]))
									}
								}
							default: return
							}
						})
						keyFrame.values = keyFrame.values.filter({ onlyRotateValues($0) == false })
					}
					keyFrames = keyFrames + normalizedKeyFrames

					for keyFrame in keyFrames {
						let relativeStartTime = Double(keyFrame.relativeStartTime)
						let relativeDuration = Double(keyFrame.relativeDuration ?? 1.0)
						keyFrame.values.forEach({ $0.applyFrom(to: view) })
						UIView.addKeyframe(withRelativeStartTime: relativeStartTime, relativeDuration: relativeDuration) {
							keyFrame.values.forEach({ $0.applyTo(to: view) })
						}
					}
				})
			})
			if let repeatCount = propertyAnimator.repeatCount, case let .count(count) = repeatCount, count == 0 { return propertyAnimator }
			propertyAnimator.addCompletion({ _ in
				let currentContext = AnimatorContext.animatorContexts.filter({ $0.type == type && $0.viewTag == view.animatorIdentifier }).first

				if let repeatCount = currentContext?.animation(of: type).repeatCount, view.superview != nil && view.window != nil {
					let nextAnimation = self.animator(type: type, for: view, options: options)
					if case let .count(count) = repeatCount {
						let nextCount = count - 1
						nextAnimation.repeatCount = nextCount > 0 ? .count(nextCount) : nil
					}
					if let repeatCount = nextAnimation.repeatCount, case let .count(count) = repeatCount, count == 0 { return }
					nextAnimation.startAnimation()
					currentContext!.add(nextAnimation)
				}
			})
			return propertyAnimator
		}

		open func animate(view: UIView, type: AnimationType, action: AnimationAction = .start, options: AnimationConfigOptions?) {
			let currentContext = AnimatorContext.animatorContexts.filter({ $0.type == type && $0.viewTag == view.animatorIdentifier }).first

			switch action {
			case .start:
				if let animator = currentContext?.animation(of: type) {
					if animator.isRunning == false {
						animator.startAnimation()
					}
					return
				}
				view.animatorIdentifier = UUID().uuidString
				let context = AnimationContext(viewTag: view.animatorIdentifier!, type: type)
				let animation = animator(type: type, for: view, options: options)
				let delay = options?.delay ?? (delayAnimation(of: type, for: view) ?? 0.0)
				animation.startAnimation(afterDelay: TimeInterval(delay))
				context.add(animation)
				AnimatorContext.animatorContexts.append(context)
			case .pause:
				var animation = currentContext?.animation(of: type)
				var fractionComplete: CGFloat?
				if animation != nil && (view.layer.animationKeys() == nil || view.layer.animationKeys()?.count == 0) {
					currentContext?.remove(animation!)
					fractionComplete = animation?.fractionComplete
					animation?.stopAnimation(false)
					animation?.finishAnimation(at: .end)
				}
				if let fractionComplete = fractionComplete {
					view.animatorIdentifier = UUID().uuidString
					let context = AnimationContext(viewTag: view.animatorIdentifier!, type: type)
					animation = animator(type: type, for: view, options: options)
					animation!.fractionComplete = fractionComplete
					context.add(animation!)
					AnimatorContext.animatorContexts.append(context)
				}
				currentContext?.animation(of: type).pauseAnimation()
			case .fractionComplete(let fraction):
				var animation = currentContext?.animation(of: type)
				var shouldRecreate = false
				if animation != nil && (view.layer.animationKeys() == nil || view.layer.animationKeys()?.count == 0) {
					currentContext?.remove(animation!)
					animation?.stopAnimation(false)
					animation?.finishAnimation(at: .end)
					shouldRecreate = true
				}

				if (fraction == 0 && animation == nil) || shouldRecreate {
					view.animatorIdentifier = UUID().uuidString
					let context = AnimationContext(viewTag: view.animatorIdentifier!, type: type)
					animation = animator(type: type, for: view, options: options)
					context.add(animation!)
					AnimatorContext.animatorContexts.append(context)
				}
				if animation!.isRunning { animation?.pauseAnimation() }
				if #available(iOS 11.0, *) {
					animation?.pausesOnCompletion = true
				}
				animation?.fractionComplete = fraction
			case .stop(let withoutFinishing):
				guard let animator = currentContext?.animation(of: type), animator.isRunning else { return }
				animator.stopAnimation(withoutFinishing)
			}
		}

		//MARK: - rotate
		public var _rotate: rotateAppearanceProxy?
		open func rotateStyle() -> rotateAppearanceProxy {
			if let override = _rotate { return override }
				return rotateAppearanceProxy(proxy: { return BaseStyle.shared() })
			}
		public var rotate: rotateAppearanceProxy {
			get { return self.rotateStyle() }
			set { _rotate = newValue }
		}
		open class rotateAppearanceProxy {
			public let mainProxy: () -> BaseStyle
			public init(proxy: @escaping () -> BaseStyle) {
				self.mainProxy = proxy
			}

		//MARK: keyFrames 
		public var _keyFrames: [KeyFrame]?
		open func keyFramesProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> [KeyFrame] {
			if let override = _keyFrames { return override }
			return [
			KeyFrame(relativeStartTime: 0.0, relativeDuration: nil, values: 
			[
			.rotate(from: 
			CGFloat(0.0), to: 
			CGFloat(360.0))])]
			}
		public var keyFrames: [KeyFrame] {
			get { return self.keyFramesProperty() }
			set { _keyFrames = newValue }
		}

		//MARK: delay 
		public var _delay: CGFloat?
		open func delayProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
			if let override = _delay { return override }
			return CGFloat(0.0)
			}
		public var delay: CGFloat {
			get { return self.delayProperty() }
			set { _delay = newValue }
		}

		//MARK: duration 
		public var _duration: CGFloat?
		open func durationProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
			if let override = _duration { return override }
			return mainProxy().Duration.interval.longProperty(traitCollection)
			}
		public var duration: CGFloat {
			get { return self.durationProperty() }
			set { _duration = newValue }
		}

		//MARK: repeatCount 
		public var _repeatCount: AnimationRepeatCount?
		open func repeatCountProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> AnimationRepeatCount {
			if let override = _repeatCount { return override }
			return AnimationRepeatCount.count(0)
			}
		public var repeatCount: AnimationRepeatCount {
			get { return self.repeatCountProperty() }
			set { _repeatCount = newValue }
		}

		//MARK: curve 
		public var _curve: AnimationCurveType?
		open func curveProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> AnimationCurveType {
			if let override = _curve { return override }
			return mainProxy().TimingFunctions.easeInProperty(traitCollection)
			}
		public var curve: AnimationCurveType {
			get { return self.curveProperty() }
			set { _curve = newValue }
		}
		}
	

}
}
extension Button: AppearaceProxyComponent {

	public typealias ApperanceProxyType = BaseStyle.ButtonAppearanceProxy
	public var appearanceProxy: ApperanceProxyType {
		get {
			if let proxy = objc_getAssociatedObject(self, &__ApperanceProxyHandle) as? ApperanceProxyType {
				if !themeAware { return proxy }


				return proxy
			}

			return StyleManager.stylesheet(BaseStyle.shared()).Button
		}
		set {
			objc_setAssociatedObject(self, &__ApperanceProxyHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
			didChangeAppearanceProxy()
		}
	}

	public var themeAware: Bool {
		get {
			guard let proxy = objc_getAssociatedObject(self, &__ThemeAwareHandle) as? Bool else { return true }
			return proxy
		}
		set {
			objc_setAssociatedObject(self, &__ThemeAwareHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
			isObservingDidChangeTheme = newValue
		}
	}

	fileprivate var isObservingDidChangeTheme: Bool {
		get {
			guard let observing = objc_getAssociatedObject(self, &__ObservingDidChangeThemeHandle) as? Bool else { return false }
			return observing
		}
		set {
			if newValue == isObservingDidChangeTheme { return }
			if newValue {
				NotificationCenter.default.addObserver(self, selector: #selector(didChangeAppearanceProxy), name: Notification.Name.didChangeTheme, object: nil)
			} else {
				NotificationCenter.default.removeObserver(self, name: Notification.Name.didChangeTheme, object: nil)
			}
			objc_setAssociatedObject(self, &__ObservingDidChangeThemeHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
		}
	}
}

extension UIViewPropertyAnimator {

	public var repeatCount: AnimationRepeatCount? {
		get {
			guard let count = objc_getAssociatedObject(self, &__AnimatorRepeatCountHandle) as? AnimationRepeatCount else { return nil }
			return count
		}
		set { objc_setAssociatedObject(self, &__AnimatorRepeatCountHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}
}

extension UIView: AnimatorProxyComponent {

	public var animatorIdentifier: String? {
		get {
			guard let identifier = objc_getAssociatedObject(self, &__AnimatorIdentifierHandle) as? String else { return nil }
			return identifier
		}
		set { objc_setAssociatedObject(self, &__AnimatorIdentifierHandle, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC) }
	}

	public typealias AnimatorProxyType = BaseStyle.AnimatorAnimatorProxy
	public var animator: AnimatorProxyType {
		get {
			guard let a = objc_getAssociatedObject(self, &__AnimatorProxyHandle) as? AnimatorProxyType else { return StyleManager.stylesheet(BaseStyle.shared()).Animator }
			return a
		}
		set { objc_setAssociatedObject(self, &__AnimatorProxyHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) }
	}

	public func rotate(action: AnimationAction = .start, options: AnimationConfigOptions? = nil) {
		animator.animate(view: self, type: .rotate, action: action, options: options)
	}

}
