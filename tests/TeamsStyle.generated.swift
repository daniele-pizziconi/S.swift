/// Autogenerated file

// swiftlint:disable all
import UIKit

fileprivate extension UserDefaults {
	subscript<T>(key: String) -> T? {
		get { return value(forKey: key) as? T }
		set { set(newValue, forKey: key) }
	}

	subscript<T: RawRepresentable>(key: String) -> T? {
		get {
			if let rawValue = value(forKey: key) as? T.RawValue {
				return T(rawValue: rawValue)
			}
			return nil
		}
		set { self[key] = newValue?.rawValue }
	}
}

public enum Theme: Int {
	case teams
	case skype

	public var stylesheet: TeamsStyle {
		switch self {
		case .teams: return TeamsStyle.shared()
		case .skype: return SkypeStyle.shared()
		}
	}
}

public extension Notification.Name {
	static let didChangeTheme = Notification.Name("stylesheet.theme")
}

public class StylesheetManager {
	@objc dynamic public class func stylesheet(_ stylesheet: TeamsStyle) -> TeamsStyle {
		return StylesheetManager.default.theme.stylesheet
	}

	private struct DefaultKeys {
		static let theme = "theme"
	}

	public static let `default` = StylesheetManager()
	public static var S: TeamsStyle {
		return StylesheetManager.default.theme.stylesheet
	}

	public var theme: Theme {
		didSet {
			NotificationCenter.default.post(name: .didChangeTheme, object: theme)
			UserDefaults.standard[DefaultKeys.theme] = theme
		}
	}

	public init() {
		self.theme = UserDefaults.standard[DefaultKeys.theme] ?? .teams
	}
}

public class Application {
	@objc dynamic public class func preferredContentSizeCategory() -> UIContentSizeCategory {
		return .large
	}
}

fileprivate var __ApperanceProxyHandle: UInt8 = 0
fileprivate var __ThemeAwareHandle: UInt8 = 0
fileprivate var __ObservingDidChangeThemeHandle: UInt8 = 0

/// Your view should conform to 'AppearaceProxyComponent'.
public protocol AppearaceProxyComponent: class {
	associatedtype ApperanceProxyType
	var appearanceProxy: ApperanceProxyType { get }
	var themeAware: Bool { get set }
	func didChangeAppearanceProxy()
}

public extension AppearaceProxyComponent {
	public func initAppearanceProxy(themeAware: Bool = true) {
		self.themeAware = themeAware
		didChangeAppearanceProxy()
	}
}

fileprivate var __AnimatorProxyHandle: UInt8 = 0

/// Your view should conform to 'AnimatorProxyComponent'.
public protocol AnimatorProxyComponent: class {
	associatedtype AnimatorProxyType
	var animator: AnimatorProxyType { get }

}


public struct KeyFrame {
	var relativeStartTime: CGFloat?
	var relativeDuration: CGFloat?
	var values: [AnimatableProp]?
}


public enum AnimatableProp {
	case opacity(from: CGFloat?, to: CGFloat)
	case frame(from: CGRect?, to: CGRect)
	case size(from: CGSize?, to: CGSize)
	case width(from: CGFloat?, to: CGFloat)
	case height(from: CGFloat?, to: CGFloat)
	case left(from: CGFloat?, to: CGFloat)
	case rotate(from: CGFloat?, to: CGFloat)
}


public extension AnimatableProp {
	func applyFrom(to view: UIView) {
		switch self {
		case .opacity(let from, _):	if let from = from { view.alpha = from }
		case .frame(let from, _):	if let from = from { view.frame = from }
		case .size(let from, _):	if let from = from { view.bounds.size = from }
		case .width(let from, _):	if let from = from { view.bounds.size.width = from }
		case .height(let from, _):	if let from = from { view.bounds.size.height = from }
		case .left(let from, _):	if let from = from { view.frame.origin.x = from }
		case .rotate(let from, _):	if let from = from { view.transform = view.transform.rotated(by: (from * .pi / 180.0)) }
		}
	}

	func applyTo(to view: UIView) {
		switch self {
		case .opacity(_, let to):	view.alpha = to
		case .frame(_, let to):		view.frame = to
		case .size(_, let to):		view.bounds.size = to
		case .width(_, let to):		view.bounds.size.width = to
		case .height(_, let to):	view.bounds.size.height = to
		case .left(_, let to):		view.frame.origin.x = to
		case .rotate(_, let to):	view.transform = view.transform.rotated(by: (to * .pi / 180.0))
		}
	}

}

/// Entry point for the app stylesheet
public class TeamsStyle: NSObject {

	public class func shared() -> TeamsStyle {
		 struct __ { static let _sharedInstance = TeamsStyle() }
		return __._sharedInstance
	}
	//MARK: - Color
	public var _Color: ColorAppearanceProxy?
	open func ColorStyle() -> ColorAppearanceProxy {
		if let override = _Color { return override }
			return ColorAppearanceProxy()
		}
	public var Color: ColorAppearanceProxy {
		get { return self.ColorStyle() }
		set { _Color = newValue }
	}
	public class ColorAppearanceProxy {

		//MARK: yellow 
		public var _yellow: UIColor?
		open func yellowProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UIColor {
			if let override = _yellow { return override }
			return UIColor(red: 0.0, green: 0.47058824, blue: 0.83137256, alpha: 1.0)
			}
		public var yellow: UIColor {
			get { return self.yellowProperty() }
			set { _yellow = newValue }
		}
	}
	//MARK: - TimingFunctions
	public var _TimingFunctions: TimingFunctionsAppearanceProxy?
	open func TimingFunctionsStyle() -> TimingFunctionsAppearanceProxy {
		if let override = _TimingFunctions { return override }
			return TimingFunctionsAppearanceProxy()
		}
	public var TimingFunctions: TimingFunctionsAppearanceProxy {
		get { return self.TimingFunctionsStyle() }
		set { _TimingFunctions = newValue }
	}
	public class TimingFunctionsAppearanceProxy {

		//MARK: easeIn 
		public var _easeIn: UITimingCurveProvider?
		open func easeInProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UITimingCurveProvider {
			if let override = _easeIn { return override }
			return UICubicTimingParameters(controlPoint1: CGPoint(x: 1.0, y: 0.0), controlPoint2: CGPoint(x: 0.78, y: 1.0))
			}
		public var easeIn: UITimingCurveProvider {
			get { return self.easeInProperty() }
			set { _easeIn = newValue }
		}
	}
	//MARK: - Metric
	public var _Metric: MetricAppearanceProxy?
	open func MetricStyle() -> MetricAppearanceProxy {
		if let override = _Metric { return override }
			return MetricAppearanceProxy()
		}
	public var Metric: MetricAppearanceProxy {
		get { return self.MetricStyle() }
		set { _Metric = newValue }
	}
	public class MetricAppearanceProxy {

		//MARK: test 
		public var _test: CGFloat?
		open func testProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
			if let override = _test { return override }
			return CGFloat(10.0)
			}
		public var test: CGFloat {
			get { return self.testProperty() }
			set { _test = newValue }
		}
	}
	//MARK: - Animator
	public var _Animator: AnimatorAnimatorProxy?
	open func AnimatorAnimator() -> AnimatorAnimatorProxy {
		if let override = _Animator { return override }
			return AnimatorAnimatorProxy()
		}
	public var Animator: AnimatorAnimatorProxy {
		get { return self.AnimatorAnimator() }
		set { _Animator = newValue }
	}
	open class AnimatorAnimatorProxy {
		public init() {}

		//MARK: - basic
		public var _basic: basicAppearanceProxy?
		open func basicStyle() -> basicAppearanceProxy {
			if let override = _basic { return override }
				return basicAppearanceProxy()
			}
		public var basic: basicAppearanceProxy {
			get { return self.basicStyle() }
			set { _basic = newValue }
		}
		public class basicAppearanceProxy {

		//MARK: curve 
		public var _curve: UITimingCurveProvider?
		open func curveProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> UITimingCurveProvider {
			if let override = _curve { return override }
			return TeamsStyle.shared().TimingFunctions.easeInProperty(traitCollection)
			}
		public var curve: UITimingCurveProvider {
			get { return self.curveProperty() }
			set { _curve = newValue }
		}

		//MARK: keyFrames 
		public var _keyFrames: [KeyFrame]?
		open func keyFramesProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> [KeyFrame] {
			if let override = _keyFrames { return override }
			return [
			KeyFrame(relativeStartTime: 0.0, relativeDuration: nil, values: 
			[
			.rotate(from: 
			CGFloat(0.0), to: 
			CGFloat(360.0))])]
			}
		public var keyFrames: [KeyFrame] {
			get { return self.keyFramesProperty() }
			set { _keyFrames = newValue }
		}

		//MARK: duration 
		public var _duration: CGFloat?
		open func durationProperty(_ traitCollection: UITraitCollection? = UIScreen.main.traitCollection) -> CGFloat {
			if let override = _duration { return override }
			return CGFloat(2.0)
			}
		public var duration: CGFloat {
			get { return self.durationProperty() }
			set { _duration = newValue }
		}
		}
	

}
}
extension UIView: AnimatorProxyComponent {

	public typealias AnimatorProxyType = TeamsStyle.AnimatorAnimatorProxy
	public var animator: AnimatorProxyType {
		get {
			guard let a = objc_getAssociatedObject(self, &__AnimatorProxyHandle) as? AnimatorProxyType else { return StylesheetManager.stylesheet(TeamsStyle.shared()).Animator }
			return a
		}
		set {
			objc_setAssociatedObject(self, &__AnimatorProxyHandle, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
		}
	}

	public func animateBasic(with completion: (() -> Void)? = nil) -> UIViewPropertyAnimator {
		let duration = TimeInterval(animator.basic.durationProperty(traitCollection))
		let propertyAnimator = UIViewPropertyAnimator(duration: duration, timingParameters: animator.basic.curveProperty(traitCollection)) 
		propertyAnimator.addAnimations { [weak self] in
			UIView.animateKeyframes(withDuration: duration, delay: 0, options: [], animations: {
				guard let `self` = self else { return }
				let keyFrames = self.animator.basic.keyFramesProperty(self.traitCollection)
				for keyFrame in keyFrames {
					let relativeStartTime = Double(keyFrame.relativeStartTime ?? 0.0)
					let relativeDuration = Double(keyFrame.relativeDuration ?? CGFloat(duration))
					keyFrame.values?.forEach({ $0.applyFrom(to: self) })
					UIView.addKeyframe(withRelativeStartTime: relativeStartTime, relativeDuration: relativeDuration) {
						keyFrame.values?.forEach({ $0.applyTo(to: self) })
					}
				}
			})
		}
		return propertyAnimator
	}

}
